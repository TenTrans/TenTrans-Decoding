
#include <iostream>
#include <fstream>
#include "HUConfig.h"
#include "HUConfigParser.h"
#include "HUVocab.h"
#include "HUDevice.h"
#include "HUGlobal.h"
#include "HUMemory.h"
#include "cnpy.h"

#include "HUEmbeddingLayer.h"
#include "HUMultiHeadAttention.h"
#include "HULayerNorm.h"
#include "HUFFNLayer.h"
#include "HUOutputLayer.h"
#include "HUUtil.h"
#include "HUData.h"
#include "HUTensorUtil.h"
#include "HUEncoderLayer.h"
#include "HUEncoder.h" 

using namespace TenTrans;
int main(int argc, char** argv) {

    HUPtr<HUConfig> config = HUNew<HUConfig>();
    config->Init(argc, argv, HUConfigMode::translating);
    
    auto vocabs = config->get<std::vector<std::string>>("vocabs");
    HUPtr<HUVocab> srcVocab = HUNew<HUVocab>();

    srcVocab->Load(vocabs[0]);

    std::vector<DeviceId> deviceIDs = config->getDevices();
    HUPtr<HUDevice> device = HUNew<HUDevice>(deviceIDs[0]);

    HUPtr<HUMemPool> memPool = HUNew<HUMemPool>(device, 0, GROW, ALIGN);
    auto workspace = config->get<int>("workspace");
    std::cout << "[Workspace(MB)]: " << workspace <<std::endl;
    std::cout << "[Memory Pool(Byte)]: " << (workspace * MBYTE) << std::endl;
    memPool->Reserve(workspace * MBYTE);

    auto models = config->get<std::vector<std::string>>("models");
    auto modelNpz = cnpy::npz_load(models[0]);

    
    HUPtr<HUEncoder> encoder = HUNew<HUEncoder>(config, memPool, device, modelNpz, true);
    encoder->Init();

    ifstream fin1(argv[3]);
    if(!fin1.is_open())
    {
        printf("[Error] Load test file failed: %s\n", argv[3]);
        return 0;
    }

    std::vector<string> inputs;
    string source = "";
    int count = 0;
    while(getline(fin1, source))
    {
        count++;
        if (count % 2 == 0)
        {
            inputs.push_back(source);
            std::cout << "[batch_size]: " << inputs.size() << std::endl;
            HUPtr<HUTextInput> in = HUNew<HUTextInput>(inputs, srcVocab);
            HUPtr<HUBatch> batch = in->ToBatch(in->ToSents());

            auto batches = batch->data();
            for(auto& item: batches) {
                std::cout << item << " ";
            }
            std::cout << std::endl;
            encoder->Forward_test(batch);
            inputs.clear();
        }
        else
        {
            inputs.push_back(source);
        }
        
    }

    if (inputs.size() > 0)
    {
        std::cout << "[batch_size]: " << inputs.size() << std::endl;
        HUPtr<HUTextInput> in = HUNew<HUTextInput>(inputs, srcVocab);
        HUPtr<HUBatch> batch = in->ToBatch(in->ToSents());

        auto batches = batch->data();
        for(auto& item: batches) {
            std::cout << item << " ";  
        }
        std::cout << std::endl;
        encoder->Forward_test(batch);
    }
    
    return 0;
}
